proc iml;
* Integrand is n_3()*f();
start n3(x) global(RRgo, n2, p, p0, p11, z_alpha, z_Bbeta);
   return( 2*(z_alpha*sqrt(2*(1-p)/p)+z_beta*sqrt((1-p0)/p0 + (1-p1)/p1))^2/x^2);
finish;
start f(x) global(n2, p0, p1, rho);
	return(pdf('normal', x, rho, 2/n2*((1-p0)/p0 + (1-p1)/p1)));
finish;
start n3_times_f(x);
	return(n3(x)*f(x));
finish;
* Randomly generate input values;
RRgo_vec = {0, 1, 1, 2};   
n2_vec = {1, 2, 3, 4};   
p0_vec = {2, 3, 4, 5};
p11_vec = {1, 2, 3, 4};
alpha_vec = {1, 2, 3, 4};
beta_vec = {1, 2, 3, 4};

res = j(nrow(RRgo_vec),1,.);
do i = 1 to nrow(a);
	RRgo = RRgo_vec[i];
	rho = -log(RRgo);
	n2 = n2_vec[i];
	p0 = p0_vec[i];
	p11 = p11_vec[i];
	p = (p0 + p1)/2;
	alpha = alpha_vec[i];
	z_alpha = quantile('NORMAL',1-alpha);
	beta = beta_vec[i];
	z_beta = quantile('NORMAL',1-beta);
	call quad(R, "n_3_times_f", b[i]||c[i]);
	print R;
	res[i] = R;
end;
/** compare with exact answer */
create test var {"res" "RRgo_vec" "n2_vec" "p0_vec" "p11_vec" "alpha_vec" "beta_vec"};
append;
close test;
